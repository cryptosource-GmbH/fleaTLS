\documentclass[a4paper,11pt]{scrartcl}
%\documentclass[a4paper,11pt]{article}
%\documentclass{article}
%\usepackage{ams}


\usepackage{fancyhdr, blindtext}
\usepackage{hyperref}
\usepackage{url}
\usepackage{graphicx}
%\usepackage{booktabs}
\usepackage{tabularx}
\usepackage{longtable}
\usepackage[utf8]{inputenc}
\usepackage{latexsym}
\usepackage{eurosym}
\usepackage{xspace} 
\usepackage{algorithmic}
\usepackage{algorithm}
\usepackage{listings}
\usepackage{verbatim}
\usepackage{tikz}
\usetikzlibrary{shapes,arrows,fit,calc,positioning,automata}

\usepackage{colortbl}
\usepackage{ulem}
\usepackage{verbatim}
\usepackage{multirow}
\usepackage{colortbl}
\usetikzlibrary{arrows,snakes}
\usepackage[margin=2.0cm,tmargin=2.5cm,bmargin=3.5cm]{geometry}

\newcommand{\changefont}[3]{
\fontfamily{#1} \fontseries{#2} \fontshape{#3} \selectfont}
 \renewcommand{\familydefault}{\sfdefault}

\newcommand{\authEnc}{Authenticated Encryption\xspace}
\newcommand{\bacpa}{BACPA\xspace}

\newcommand{\stateUninit}{\textsc{uninitialized}\xspace}
\newcommand{\stateInit}{\textsc{initialized}\xspace}
\newcommand{\stateCreated}{\textsc{constructed}\xspace}
\newcommand{\stateDestroyed}{\textsc{destroyed}\xspace}
%\input{../../phd/thesis/newcmds.tex}
\newcommand{\paper}[1]{#1}

\definecolor{csblue}{rgb}{0.32,0.47,0.85}
\definecolor{csbluelightformer}{rgb}{0.37,0.47,0.74}
\definecolor{csbluelight}{rgb}{0.41,0.52,0.81}
\definecolor{csorange}{rgb}{0.95,0.56,0.25}
\fancyhead{}
%\fancyfoot{}

\fancyheadoffset[L]{0.9cm}
\fancyheadoffset[R]{0.4cm}
\renewcommand{\headrule}{\hbox to\headwidth{%
  \color{csbluelight}\leaders\hrule height \headrulewidth\hfill}}

\renewcommand{\headrulewidth}{1.2pt}
\fancyhead[R]{\hspace{-1.9cm}\includegraphics[width=6cm]{cs_logo.eps}}
\fancyhead[L]{flea cryptographic library 
\thisFleaVersion\\manual}
\fancyfoot[C]{\vspace{-0.3cm}\thepage}
\pagestyle{fancy}

%\ULWallPaper{bg.jpg}
\usepackage{eso-pic}
\newcommand\BackgroundIm{
  \put(5,-21){
    \parbox[b][\paperheight]{\paperwidth}{%
      \vfill
        \centering
        \includegraphics[height=\paperheight,width=\paperwidth,
        keepaspectratio]{bg.jpg}%
          \vfill
    }}}

        \renewcommand*\contentsname{\newline Contents}
\begin{document}
\AddToShipoutPicture{\BackgroundIm}
\changefont{cmss}{m}{n}
%\tikzset{XOR/.style={draw,circle,append after command={
%        [shorten >=\pgflinewidth, shorten <=\pgflinewidth,]
%        (\tikzlastnode.north) edge (\tikzlastnode.south)
%        (\tikzlastnode.east) edge (\tikzlastnode.west)
%        }
%    }
%}

\tikzstyle{manipblock} = [draw, fill=red!20, rectangle, 
    minimum height=2em, minimum width=6em]
\tikzstyle{origblock} = [draw, fill=green!20, rectangle, 
    minimum height=2em, minimum width=6em]
\tikzstyle{block} = [draw, fill=blue!20, rectangle, 
    minimum height=2em, minimum width=6em]
\tikzstyle{decbox} = [draw, fill=blue!20, rectangle, 
    minimum height=1em, minimum width=1em]
\tikzstyle{manipbytebox} = [draw, fill=red!20, rectangle, 
    minimum height=1em, minimum width=6em]
\tikzstyle{sum} = [draw, fill=blue!20, circle, node distance=1cm]

\newcommand{\code}[1]{\texttt{#1}}
\newcommand{\serverCtx}{\code{flea\_tls\_server\_ctx\_t}}
%\newcommand{\serverCtx}{\texttt{flea}}
\newcommand{\clientCtx}{\code{flea\_tls\_client\_ctx\_t}}

\newcommand{\thisFleaVersion}{v1.2\xspace }

\newcommand{\ie}{i\.e\.}
%\mainmatter              % start of the contributions
%
\title{flea cryptographic library \thisFleaVersion\\{\LARGE manual} }

\author{cryptosource GmbH,
  Darmstadt\\\url{flea@cryptosource.de}\\\url{www.cryptosource.de}\vspace{0.5cm}\\\includegraphics[width=7cm]{logo.png}}

\maketitle              % typeset the title of the contribution

%\begin{abstract}
%\end{abstract}

\newpage

\setcounter{tocdepth}{3}
\vspace{1cm}
\tableofcontents

\newpage

\section{Introduction}
flea, the acronym of ``flexible lightweight efficient algorithms'' is a
cryptographic library written in C and intended for resource
constrained devices. 
%In the current version it
%comes with a basic set of the most fundamental symmetric and asymmetric
%algorithms. 
It is especially intended to run on bare microcontrollers without
any operating system support. However, it can be readily run on standard PCs as
well. The current release of flea only supports 32-bit architectures but
compiles and runs also on 64-bit machines.


  \section{Getting started with flea}

  In order to get easily started with flea, the library is shipped with a CMake
  configuration to build it on standard Linux. In the
  flea directory, the command sequence 
  \begin{verbatim}
  cmake .
  make -j4
  ./build/unit_test
  \end{verbatim}
  can be issued to build the library, the unit tests, and execute the tests.

  However, the library is shipped in a state in which it produces two
  compilation errors. This is due to the fact that for the secure operation of
  the random number generator (RNG) of the library the user has to implement two
  functions for the persistence of the RNG state. The source code contains
  guidance how to quickly repair these compilation errors with a workaround,
  which, however, leads to an insecure build of the library that must not be
  used in production code. In Section \ref{secRng} we give guidance on how to use
  the RNG safely.

  \section{Compile-Time Configuration}

The library offers various compile-time
configuration options, such as 
\begin{itemize}
  \item the set of algorithms to include in the library
  \item use of stack memory only or the additional use of heap memory,
  \item configuration of the maximal key sizes for the determination of the
    buffer sizes in stack-only mode,
  \item buffer overwrite detection through canary values at the start and end of
    each buffer,
  \item various trade-offs concerning code-size, RAM demand and speed.
  \end{itemize}

  The compile-time configuration of the library is completely managed by a
  preprocessor framework. All configuration options can be set in the file
  \verb#build_cfg/general/build_config.h#, making it easy to configure the
  library on embedded platforms without any dependency on the build system.

  In order to build the library on an arbitrary 32-bit platform, the following
  directories must be in the compiler's include path:
  \begin{itemize}
    \item \verb#include#
    \item \verb#include/api#
    \item \verb#test/include# (in case that the unit tests shall be build)
    \item \verb#build_cfg/pltf_spec/32bit_default#
    \item \verb#build_cfg/general#
  \end{itemize}

\section{Random Number Generation }
\label{secRng}

flea features a simple but secure random number generator which is based on
the management of an RNG state file. In order to use the RNG safely in an
embedded firmware, the following steps must be taken. 

\subsection{Necessary Steps During Implementation}
During implementation, the in the file \verb#src/user/prng_user.c# the functions
for loading the PRNG state from the non-volatile memory (NVM)  and saving it to the NVM have to be
implemented. The developer must allocate an area within the device's NVM for
this purpose, the size of which is 32 bytes.

A second requirement is that during the device's startup, prior to the use of any
other functions of the flea library, the function 
\begin{verbatim}
flea_err_t THR_flea_lib__init()
\end{verbatim}
must be called, which internally loads the RNG state from NVM into the
corresponding RAM variable.


\subsection{Necessary Steps During Production and Activation}
When the devices running the firmware using flea are produced, before the
execution of any cryptographic operation, the PRNG state must be seeded with a
high entropy seed different for each device. 
%This seed should be generated on an
%external computer which has appropriate entropy sources available for this
%purpose. 
The function 
\begin{verbatim}
flea_err_t THR_flea_rng__reseed_persistent(const flea_u8_t* seed, flea_dtl_t seed_len);
\end{verbatim}
must be called once during the production or activation process with that seed data.
From that point on, the RNG state will be managed internally by the flea
library. During startup, when the function \verb#THR_flea_lib__init()# is
called, the stored RNG state is loaded from NVM to initialize the RNG, then a
fresh RNG state is created from the RNG's output and stored in the NVM. From
that point on, the RNG operates efficiently with its RAM state and secure,
non-repetitive random number generation is ensured even after a reset. 

\section{Using flea's API}

flea uses a macro framework to abstract object and buffer initialization as well
as error handling. This allows for greater flexibility and security for a number of reasons:
\begin{itemize}
  \item it is possible to switch between stack and heap usage for buffer allocation
  by changing a single compiler flag,
  \item the life cycles of buffers and objects are formalized and integrate
    seamless with the error handling, guaranteeing safety from resource leaks
    and errors such as use-after-free if the programming standards are adhered
    to.
\end{itemize}

From the following sections, only Sections \ref{secFleaObj} and \ref{secErrRet}
are essentially
important for users of the library since the other sections describe the
internal design of flea which is not necessary for the use of its API. But since
the test code shipped with flea, which can serve as a source of example code, is
written in the same framework, it is helpful to understand also the approaches
to error handling and buffer management outlined in the subsequent sections.
\subsection{flea's Objects}
\label{secFleaObj}
flea's objects have the following life cycle states:
\begin{itemize}
  \item \stateUninit. This state is entered by simply declaring an object on
    stack or heap without assigning any value to it. From this state, only the
    transition to the state \stateInit is allowed.
  \item \stateInit. This state is entered via one of the following means:
    \begin{itemize} 
        \item By using the macro
    \verb#FLEA_DECL_OBJ(symbol_name, object_type)# for the object declaration
    and simultaneous initialization. 
    \item Alternatively, an object in the state
    \stateUninit can make the transition to the state \stateInit by invoking the
    corresponding initialization macro.
    Their naming pattern is \verb#flea_<type>__INIT(symbol_address)#.
    In the state \stateInit, only two
    actions may be performed on the object: The object's destructor (dtor)
    function or one of its constructor (ctor) functions may be called.
\end{itemize}
  \item \stateCreated. This state can be entered in two ways
    \begin{itemize}
    \item By the calling one of the object's
    ctor functions or other functions which perform object creation. The state
    \stateCreated can only be left by calling the object's dtor function. If a
    function returns when any of its objects are in the state \stateCreated,
    then this will result in a memory leak in the case of heap mode.
    \item Alternatively, for some objects, the exist also initialization value
      macros labelled conforming to the naming pattern
      \verb#flea_<type>__CONSTR_<further specification>#. An object initialized
      with such a value is in the state \stateCreated afterwards.
  \end{itemize}
  \item \stateDestroyed. This state is entered by calling the object's dtor
    function. In this state, the dtor function may be called repeatedly (without
    any effect) or the object may be created again using a ctor function.
\end{itemize}

This is the contract offered by all class-like types of flea's API. The dtor calls should
be made even in the stack-only mode, because they wipe secret values from the
RAM before deallocation.

The flea library functions themselves realize an approach which ensures that all
requirements from flea life object cycle model are met. This approach is
described in Section \ref{fleaFuncSkel} and it is recommended to adapt it in implementations
using flea or realize a corresponding solution.


\subsection{Error Return Values}
\label{secErrRet}
Any function of flea that potentially returns an error, referred to as a throwing function, can be identified by starting with the string
\verb#THR_#. Such a function returns \verb#FLEA_ERR_FINE#, which is defined as
zero, upon success or one of the error codes define in \verb#flea/error.h# otherwise.
When calling throwing functions in flea it is necessary test their return value
and take appropriate actions if an error occured.

\subsection{Object Life Cycle and Error Handling within the flea Library Functions}
\label{fleaFuncSkel}
In order to establish a standardized and robust approach to object initialization,
object creation, object destruction and error handling, the flea library
function implementations themselves employ a dedicated macro framework. This
approach is described in the following to facilitate the understanding of the
implementation. Furthermore, it may be be adapted in the flea library user's own
code.

Specifically, any throwing function in flea is structured by the following skeleton:
\begin{verbatim}
  <declaration section>
  FLEA_THR_BEG_FUNC();
  <initialization section>
  <throwing section> 
  FLEA_THR_FIN_SEC(cleanup-code);
\end{verbatim}
In the \verb#declaration section# all variable declaration happen. Next, in the \verb#initialization section#  
all objects so far not initialized are initialized by means of the
corresponding initialization macros. Any throwing functions may only be called
after this section in the \verb#throwing section#. 
The \verb#cleanup-code# is the code that shall be executed whenever the function ends,
either by naturally running to the location of the macro call
\verb#FLEA_THR_FIN_SEC()# or because between the two macro calls an error was
thrown and not handled, causing an immediate jump to the cleanup-code. This can happen mainly due to two incidents:
\begin{itemize}
  \item An error was raised by calling the macro \verb#FLEA_THROW()#. This
    causes the routine to directly jump to the cleanup code and the function
    returns the error code raised by \verb#FLEA_THROW()#. 
  \item An error was returned by a throwing function called as
    \verb#FLEA_CCALL(THR_flea_some_function(args))#. The behaviour is the same
    as for the \verb#FLEA_THROW()# macro, i.e. a return value other than
    \verb#FLEA_ERR_FINE# causes an immediate jump to the cleanup-code. In this, the error code returned by the
    called function is returned by the current function.
\end{itemize}

It is important to stress that in order to have correct life cycle management even in the presence of errors
thrown directly in the code or returned by called functions, one essential rule must be followed:
Before any code is executed that potentially raises errors, all objects 
used within the function must have be initialized. 
  %  If only the \verb#FLEA_DECL_OBJ()# is used for the
  %  object declaration, then this is naturally achieved. 
    %If, however, any
    %objects are declared in the standard way and only initialized in the
    %initialization-section indicated above, then it is vital that no error
    %throwing code is executed in the initialization section.
%  \end{enumberate}
Following this rule ensures that the jump to the cleanup section, which
typically executes the dtors for all local objects, is possible at any time
during error-throwing code.

\subsection{Buffer Management}
The buffer management in flea is abstracted by macros in order to enable both
the abstraction from heap/stack usage and in order to enable the use of canary
values for buffer overwrite detection.

The following  macros are mainly employed for the buffer management:
\begin{itemize}
  \item \verb#FLEA_DECL_BUF(symbol_name, type, size)# declares a buffer, 
  \item \verb#FLEA_ALLOC_BUF(symbol_name, size)# allocates a buffer, 
  \item \verb#FLEA_FREE_BUF_FINAL(symbol_name)# frees a buffer,
  \item \verb#FLEA_FREE_BUF_SECRET_ARR(symbol_name, size)# also frees a buffer,
    but also overwrites the memory contents prior to that.
\end{itemize}
All buffer sizes are specified in element counts, not in bytes. However, the
user of the library, who does not intend to make use of flea's features for 
switching between stack and heap mode in his own code or use the buffer
canaries, may certainly use any explicit heap or stack buffer allocation as he
is used to.

%\section{Concurrency Support}

%Concurrency support for TLS server session manager: all connections must be
%closed before the session manager is destroyed.


\section{The TLS API}

flea implements the TLS 1.2 protocol for the instantiation of TLS clients and
server. 

\section{A brief description of the TLS protocol}
TLS is a protocol which allows for the establishment of secure connections
between a TLS client and a TLS server. The authenticity of the server, and
optionally that of the client is ensured by the use of X.509 certificates.
During the so-called TLS handshake the authenticity of the X.509 certificate of
the peer is verified and based on the public key presented in that certificate
a key exchange (KEX) is performed. As a result, after the TLS handshake, both
sides share a set of symmetric keys for the encryption and authentiation of the
payload data, also referred to as application data. 
At this point, both peers
can send application data to each other in a confidential and authentic manner.
The concrete cryptographic algorithms that are used during the handshake and for the
transmission of the application data, are specified by the so-called TLS
cipher suite.

\subsection{Overview of the TLS Protocol Flow}
\begin{figure}
\input{./figures/tlsSeqFlow.tex}
\caption{Overview of the potential events during the TLS protocol flow and the
associated functions of the flea TLS Client and Serve API.}
\label{figTlsSeqFlow}
\end{figure}

Figure \ref{figTlsSeqFlow} shows the potential events in the TLS protocol flow
and the associated functions of the fleaTLS client and server API. Any TLS
connections starts with a call to the ctor function of the TLS client
(\clientCtx) or server (\serverCtx) context object.

\subsubsection{Initial Handshake and Application Data Transfer}
After the initial handshake, the TLS channel is established and all subsequent
data exchanges between the peers take place over the secure TLS channel. The
main purpose of the TLS channel is the secure exchange of application data,
which is done using the fleaTLS functions 
\begin{itemize}
  \item THR\_flea\_tls\_client\_ctx\_t\_\_read\_app\_data()
  \item THR\_flea\_tls\_client\_ctx\_t\_\_send\_app\_data()
  \item THR\_flea\_tls\_server\_ctx\_t\_\_read\_app\_data()
  \item THR\_flea\_tls\_server\_ctx\_t\_\_send\_app\_data()
\end{itemize}

Note that in order to ensure the sending of the application over the wire a call
to 
\begin{itemize}
  \item \code{THR\_flea\_tls\_client\_ctx\_t\_\_flush\_write\_app\_data} or
  \item \code{THR\_flea\_tls\_server\_ctx\_t\_\_flush\_write\_app\_data}
  \end{itemize}
  is necessary since the \code{send\_app\_data} functions may buffer the data.

  \subsubsection{Renegotiation}
A renegotiation can be triggered either by a call to the corresponding
renegotiation function
\begin{itemize}
  \item \code{THR\_flea\_tls\_client\_ctx\_t\_\_renegotiate} or
\item \code{THR\_flea\_tls\_server\_ctx\_t\_\_renegotiate}
  \end{itemize}
  or during a call to a \code{read\_app\_data} function, if the peer initiates a
  renegotiation during that call which is accepted by flea.

  The conditions for accepting a renegotation request by the  fleaTLS client or
  server are the following:
  \begin{itemize}
    \item If in the TLS client or server context object's ctor call the flag \code{flea\_tls\_flag\_reneg\_\_allow\_insecure\_reneg} is
      set, then the renegotation request is accepted under any condition.
    \item If in the TLS client or server context object's ctor call the flag \code{flea\_tls\_flag\_reneg\_\_allow\_only\_secure\_reneg} is
      set, then the renegotation request is accepted if the peer also supports
      the Renegotiation Indication Extension and behaves correctly with respect
      to this extension.
      \item If in the TLS client or server context object's ctor call the flag \code{flea\_tls\_flag\_reneg\_\_no\_reneg} is
      set, then the renegotation request is declined unconditionally.
  \end{itemize}

  The closing of a connection happens when dtor function of the respective tls
  client or server context object is called. Furthermore, the connection is
  closed if an error occurs during any of the other TLS client or server context
  objects.
%TODO: FIGURE:
%handshake
%  client hello
%  server hello
%  \ldots
%tls channel
%  renegotiate
%  read/write app data

  \subsubsection{TLS Alert Handling and Sending }

  In the TLS protocol alert messages are specified as a menas to signal error
  conditions to the peer. The carry a type and a level field. A variety of possible types
  is specified in the TLS standard. The level can be \emph{fatal}, indicating an error
  that mandates the ending of the connection, or \emph{warning}, indicating that,
  depending on the type of the alert, the a specific action may be necessary.
  fleaTLS completely handles the treatment of incoming
  TLS alerts and sending of alerts when an error condition is met.

  If fleaTLS receives an alert the reaction is determined according to the
  following rules:
  \begin{itemize}
    \item If the alert has level \emph{fatal}, flea closes the connection and the API
        function during the execution of which the alert was received returns an
        error code.
      \item Otherwise, if the alert has level \emph{warning}, and
        \begin{itemize}
          \item if it is of type \emph{close notify}, then the connection is closed as
            well, \ie fleaTLS sends a \emph{close notify} alert to the peer itself;
          \item if it is of type \emph{no renegotiation}, and fleaTLS is
            currently executing the TLS client's or server's
            \code{renegotate()} function, then it aborts the renegotation and
            indicates this to the user. The TLS context object remains valid in
            this case.

  \end{itemize}
  \end{itemize}

\subsection{Ciphersuites}

The TLS protocol defines a large variety of cipher suites. fleaTLS
\thisFleaVersion supports the following subset of cipher suites.
\begin{itemize}
  \item TLS\_RSA\_WITH\_AES\_128\_CBC\_SHA
  \item TLS\_RSA\_WITH\_AES\_128\_CBC\_SHA256
  \item TLS\_RSA\_WITH\_AES\_256\_CBC\_SHA
  \item TLS\_RSA\_WITH\_AES\_256\_CBC\_SHA256
  \item TLS\_RSA\_WITH\_AES\_128\_GCM\_SHA256
  \item TLS\_RSA\_WITH\_AES\_256\_GCM\_SHA384
  \item TLS\_ECDHE\_RSA\_WITH\_AES\_128\_CBC\_SHA
  \item TLS\_ECDHE\_RSA\_WITH\_AES\_256\_CBC\_SHA
  \item TLS\_ECDHE\_RSA\_WITH\_AES\_128\_CBC\_SHA256
  \item TLS\_ECDHE\_RSA\_WITH\_AES\_128\_GCM\_SHA256
  \item TLS\_ECDHE\_RSA\_WITH\_AES\_256\_CBC\_SHA384
  \item TLS\_ECDHE\_RSA\_WITH\_AES\_256\_GCM\_SHA384
\end{itemize}

These strings specify the cryptorgraphic algorithms that are used during the TLS
handshake according to the following pattern:

$$
\mathrm{TLS\_}\underbrace{\mathrm{RSA}}_{\mathrm{KEX}}\mathrm{\_WITH\_}\underbrace{\mathrm{AES\_128}}_{cipher}\_\underbrace{\mathrm{CBC}}_{mode
}\_\underbrace{\mathrm{SHA}}_{hash }
$$
\begin{description}
  \item[KEX] The key exchange algorithm specifies the algorithm which is used
    for the exchange of the symmetric keys used in the TLS channel. The current
    version of fleaTLS supports only the RSA and ECDHE\_RSA KEX. In the former,
    the RSA key from the certificate of the server is directly used for the KEX,
    Tin the latter the RSA key of the server signs an ephemeral ECDH key, which
    in turn is used for the key exchange. This implies that the
    certificate of the server must be an RSA certificate.
  \item[cipher] The cipher is the encryption primitive which is used to achieve
    the confidentiality within the TLS channel. fleaTLS only supports the AES
    algorithm (with key sizes 128 and 256 as specified in the TLS protocol).
  \item [mode] The encryption mode in which the cipher is used. 
  \item[hash] The hash algorithm which is specified here is used for the
    authentication of the channel data.
  \end{description}
The support for the individual cipher suites is configured in the general build
configuration file with the corresponding defines prefixed with FLEA\ldots .


\subsection{Requirements for Server Certificates}

The current version of flea only supports the RSA KEX during the TLS handshake.
This implies that the server must present an RSA certificate during the
handshake. This certificate must feature an RSA public key.

The server certificate does not necessarily have to include any certificate
extensions. However, if certain extensions are present, then the following
requirements must be fullfilled according to the TLS standard.
\begin{description}
  \item [Key Usage Extension] If present, this extension must feature at least
    the \emph{keyEncipherment} key usage.
  \item [Extended Key Usage Extension] If present, this extension must feature
    the key usage \emph{serverAuth} or \emph{any}.
  \item [Subject Alternative Name] This extension is recommended to be encluded
    in the certificate and to include either the IP address or the DNS name of
    the server. If this extension is not present, the client will use the Common
Name within the certificate to verify the DNS name.
\end{description}


\subsection{Requirements for Client Certificates}

If TLS client authentication is used, then the client also presents a
certificate chain. In the current version of flea, the client certificate must
be an RSA certificate. Furthermore the following requirements must be fulfilled
for the certificate extensions of this certificate according to the TLS standard.
\begin{description}
  \item [Key Usage Extension] If present, this extension must feature at least
    the \emph{digitalSignature} key usage.
  \item [Extended Key Usage Extension] If present, this extension must feature
    the key usage \emph{clientAuth} or \emph{any}.
\end{description}

\subsection{TLS Extensions}

The TLS protocol features a number of so-called TLS extension. These are
optional extensions of the basic protocol. They are sent during the Client Hello
and/or Server Hello messages. 
\subsubsection{Renegotiation Indication Extension}
Renegotiation Indication Extension is specified in RFC 5746 and has the purpose
of preventing certain data injection attacks. fleaTLS supports this extension
according to the standard.  

This extension restricts the possibility of performing a TLS renegotiation under
certain conditions. This depends on the support of the peer for this extension
and the configuration of the flea TLS instance. 

TODO:EXPLAIN THE 3 VARIANTS

\subsubsection{Signature Algorithms Extension the TLS Handshake}



\subsection{TLS Alerts}
TODO

\section{Instantiating fleaTLS Server and Client}

The fleaTLS server and client API objects are given by the
\serverCtx and \clientCtx. Their lifecycle is modelled such that their
constructor call carries out the TLS handshake. The constructed object is thus
directly in the state where the TLS channel is established and data can be
exchanged.

\section{Support}
cryptosource provides commercial support for the flea library. Please visit
\url{http://cryptosource.de/product_flea_en.html} for further information or
contact us at \url{flea@cryptosource.de}.

\end{document}
